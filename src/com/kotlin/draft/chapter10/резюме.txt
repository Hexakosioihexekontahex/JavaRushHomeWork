
    Синтаксис применения аннотаций в Kotlin практически неотличим от Java.

    Kotlin позволяет применять аннотации к более широкому кругу элементов,
    чем Java, включая файлы и выражения.

    Аргумент аннотации может быть значением простого типа, строкой,
    перечислением, ссылкой на класс, экземпляром класса другой аннотации или
    их массивом.

    Определяя целевой элемент аннотаций в месте использования, например
    @get:Rule, можно указать, к какому элементу применяется аннотация, если
    единственное объявление на Kotlin порождает несколько элементов в байт-коде.

    Класс аннотации объявляется как класс с основным конструктором, не
    имеющим тела, все параметры которого являются val-свойствами.

    С помощью метааннотаций можно определить цель, режим сохранения и другие
    атрибуты аннотаций.

    Механизм рефлексии позволяет перебирать и обращаться к методам и свойствам
    объектов во время выполнения. Он имеет интерфейсы, представляющие разные виды
    объявлений, такие как классы (KClass), функции (KFunction) и так далее.

    Получить экземпляр KClass можно с помощью ClassName::class, если класс
    заранее известен, или obj.javaClass.kotlin, чтобы получить класс экземпляра
    объекта.

    Оба интерфейса, KFunction и KProperty, наследуют KCallable, который определяет
    обобщенный метод call.

    Для вызова методов, имеющих параметры со значениями по умолчанию, можно
    использовать метод KCallable.callBy.

    KFunction0, KFunction1 и так далее - это функции с разным количеством
    параметров, которые можно использовать для вызова методов.

    KProperty0 и KProperty1 - это свойства с разным количеством приемников. Они
    поддерживают метод get для получения значения. KMutableProperty0 и
    KMutableProperty1 наследуют эти интерфейсы для поддержки свойств, позволяющих
    изменять значения вызовом метода set.
